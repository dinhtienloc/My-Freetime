/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fun>
#include <hamsandwich>
#include <fakemeta>
#include <ColorChat>
#include <engine>
#include <cstrike>
#include <cs_player_models_api>
#include <fakemeta_stocks>
#include <dhudmessage>

#define PLUGIN "Minigames"
#define VERSION "1.0"
#define AUTHOR "Elo_Cee"

#define OFFSET_CLIPAMMO        51
#define OFFSET_LINUX_WEAPONS    4
#define OFFSET_TEAM	114

#define m_pActiveItem 373

#define fm_cs_set_weapon_ammo(%1,%2)    set_pdata_int(%1, OFFSET_CLIPAMMO, %2, OFFSET_LINUX_WEAPONS)
#define fm_cs_set_user_nobuy(%1)   	set_pdata_int(%1, 235, get_pdata_int(%1, 235) & ~(1<<0))

#define fm_get_user_team(%1)		get_pdata_int(%1,OFFSET_TEAM)
#define fm_set_user_team(%1,%2)		set_pdata_int(%1,OFFSET_TEAM,%2)

#define flag_get(%1,%2) 		(%1 & (1 << (%2 & 31)))
#define flag_get_boolean(%1,%2) 	(flag_get(%1,%2) ? true : false)
#define flag_set(%1,%2) 		%1 |= (1 << (%2 & 31))
#define flag_unset(%1,%2) 		%1 &= ~(1 << (%2 & 31))

#define TASK_START 100
#define TASK_COUNTDOWN 200
#define TASK_BOMBCOUNTDOWN 300
#define TASK_CHOOSEBOMBERAGAIN 400
#define TASK_GIVESMOKENADE 500
#define TASK_SPEEDCHECK 600
#define TASK_CHOOSEMODE 700
#define TASK_LIGHTNORMAL 800
#define TASK_LIGHTDARK 900
#define TASK_MODENAME 1000
#define TASK_MODEDES 1100

#define COUNTDOWN 3

#define IN_FORWARD                      (1<<3)
#define IN_BACK                         (1<<4)
#define IN_MOVELEFT                     (1<<9)
#define IN_MOVERIGHT                    (1<<10)

new const Ham:Ham_Player_ResetMaxSpeed = Ham_Item_PreFrame;
const NOCLIP_WPN_BS    = ((1<<CSW_HEGRENADE)|(1<<CSW_SMOKEGRENADE)|(1<<CSW_FLASHBANG)|(1<<CSW_KNIFE)|(1<<CSW_C4))

new const pl_cm_class[] = "PlayerCamera"
new g_remove[32]

new g_isHoldingBomb, g_isChicken

enum _:MODES_COUNT
{
NORMAL = 0,               //0
SCOUT_NOZOOM_MODE,	//1
KNIFE_HP_MODE,		//2
INVISIBLE_MODE,		//3
TPV_MODE,		//4 // 3rd Person View mode
CHANGEMODEL_MODE,	//5
RUN_MODE,		//6
BOMB_MODE,		//7
CHICKEN_MODE,		//8
ZEUS_MODE,		//9
RAMBO_MODE,		//10
REVERSE_MODE,		//11
ONEBUTTON_MODE,		//12
UPSIDE_DOWN_MODE,	//13
AWP_JUMP_MODE,		//14
NIGHTMARE_MODE,		//15
DEATHLYNADE_MODE,	//16
FLY_MODE		//17
//SPEED_MODE
}

enum _:SPEED_STATUS
{
ENABLED = 0,
WAIT,
DISABLED
}

//new const g_PlayerModel[8][] = {"sas", "arctic", "gsg9", "leet", "urban", "terror", "gign", "guerilla"}
new const g_MaxClipAmmo[] = {
0,
13, //CSW_P228
0,
10, //CSW_SCOUT
0,  //CSW_HEGRENADE
7,  //CSW_XM1014
0,  //CSW_C4
30,//CSW_MAC10
30, //CSW_AUG
0,  //CSW_SMOKEGRENADE
15,//CSW_ELITE
20,//CSW_FIVESEVEN
25,//CSW_UMP45
30, //CSW_SG550
35, //CSW_GALIL
25, //CSW_FAMAS
12,//CSW_USP
20,//CSW_GLOCK18
10, //CSW_AWP
30,//CSW_MP5NAVY
100,//CSW_M249
8,  //CSW_M3
30, //CSW_M4A1
30,//CSW_TMP
20, //CSW_G3SG1
0,  //CSW_FLASHBANG
7,  //CSW_DEAGLE
30, //CSW_SG552
30, //CSW_AK47
0,  //CSW_KNIFE
50//CSW_P90
}

new g_szGrenadeNames[ ][ ] = {
"", // ERROR
"weapon_hegrenade",
"weapon_flashbang",
"weapon_smokegrenade"
};

new g_lastmode
new g_nextmode
new g_currentmode
new g_extraVar

// Name of mode
new g_szMode[MODES_COUNT][] = {
"Default",
"Scout master",
"Knife round",
"I can't see you",
"Play like GTA",
"Teammates or enemies???",
"Run...",
"Avoid the bomb",
"Catch the chicken",
"Zues round",
"We are Rambo",
"Strange Movement",
"One button is allowed",
"Up is down. Down is up",
"Jump! Jump! Jump! Like a bunny",
"The nightmare begins!!",
"The power of nades",
"Fly, fly and fly"
}

// Weapon player can use each mode
new g_szWeapon[MODES_COUNT][] = {
"Everything",  
"Scout",
"Knife",
"Everything",
"Everything",
"Everything",
"Everything",
"Nothing",
"Everything",
"Zeus",
"M249",
"Everything",
"Everything",
"Everything",
"AWP",
"Everything",
"Smokegrenade",
"Everything"
}

// Some stupid discribe for each mode
new g_szDescribe[MODES_COUNT][] = {
"",
"No-zoom",
"",
"The faster you run, the less you visible",
"No more FPV. This is 3rd Person View",
"Kill teammate - You will die!!!",
"Run as fast as you can. If not - Booooooom",
"Chosen person will explode after 10 seconds",
"Find and kill the chicken or it will cut you down",
"A weapon from CS:GO",
"Boost speed",
"",
"",
"Your screen? What happened?",
"Auto Bhop",
"Everything is black",
"Kill enemies with your smokegrenade",
"Play while noclip"
}

new cvar_damageradius, 	// Bomb mode
cvar_runminspeed,	// Run mode
cvar_lightfreq	// Nightmare mode

new g_iCountdown
new g_iMaxPlayers
new mp_freezetime

// Run Mode
new g_speedCheck;

// Bomb Mode
new g_iBombCountdown
new g_SprExplode[13]
new g_SprCountdown[10]
new g_SprSmoke
new g_SprShockware
new g_SprRandom
new g_MdlChromeGibs

//Chicken Mode
new const g_MdlChicken[] = "chicken";

//Bomb mode
new g_choosePlayer
new beep_sound[] = "weapons/mm_bomb_beep.wav"

//Change model mode
new mp_friendlyfire
new const g_MdlTroller[] = "nguoique";
new bool:g_HookState
new HamHook:g_hTraceAttack, HamHook:g_hTakeDamage, HamHook:g_hKilled, g_mRadarHook
new gmsgRadar

// Only one button mode
new g_AllowButton

// Upside down mode
new Float:g_vecPunchAngles[32][3]

// DeathlyNade Mode
new Float:g_flLastTouch[32];
new g_iHookedDeathMsg
new g_iMsg_DeathMsg

public plugin_init() {
register_plugin(PLUGIN, VERSION, AUTHOR)

//RegisterHam(Ham_Spawn, "player", "FwdPlayerSpawn", 1)
//RegisterHam(Ham_Killed, "player", "FwdPlayerDeath", 1)
register_think(pl_cm_class,"Think_PlayerCamera")
RegisterHam( Ham_Weapon_SecondaryAttack, "weapon_awp"  , "OnSecondaryAttack" );
RegisterHam( Ham_Weapon_SecondaryAttack, "weapon_scout", "OnSecondaryAttack" );
RegisterHam(Ham_Spawn, "player", "HamSpawn", 1)
RegisterHam(Ham_Player_ResetMaxSpeed, "player", "CBasePlayer_ResetMaxSpeed", 1 );
RegisterHam( Ham_Touch, "grenade", "FwdHamTouch_Grenade" );

g_hTraceAttack = RegisterHam(Ham_TraceAttack, "player", "TraceAttack")
g_hTakeDamage = RegisterHam(Ham_TakeDamage, "player", "TakeDamage")
g_hKilled = RegisterHam(Ham_Killed, "player", "Killed")

register_forward(FM_CreateNamedEntity, "CreateNamedEntity")
//register_forward(FM_TraceLine, "fw_traceline")
//register_forward(FM_TraceHull, "fw_tracehull", 1)
register_forward(FM_CmdStart, "FMCmdStart")
register_forward(FM_EmitSound, "OnEmitSound", false)


register_event("HLTV", "Event_NewRound", "a", "1=0", "2=0")
register_event("CurWeapon" , "Event_CurWeapon" , "be" , "1=1" );
register_event("DeathMsg", "EventDeathMsg", "a");

register_logevent("logevent_round_end", 2, "1=Round_End")


g_iMaxPlayers = get_maxplayers();


g_iMsg_DeathMsg = get_user_msgid("DeathMsg");

// CVAR
cvar_damageradius = register_cvar("mm_dmgradius", "150.0");
cvar_runminspeed = register_cvar("mm_run_minspeed", "200.0");
cvar_lightfreq = register_cvar("mm_light_freq", "5.0");
server_cmd("sv_maxspeed 1000");
server_cmd("sv_maxvelocity 20000");

}

public plugin_cfg() {
mp_friendlyfire = get_cvar_pointer("mp_friendlyfire")
mp_freezetime = get_cvar_pointer("mp_freezetime");

set_pcvar_num(mp_freezetime, 5);
}

public plugin_natives(){
register_library("minigames");
register_native("mm_get_last_mode", "_mm_get_last_mode");
register_native("mm_get_current_mode", "_mm_get_current_mode");
register_native("mm_get_next_mode", "_mm_get_next_mode");
}

public _mm_get_current_mode() {
return g_currentmode;
}

public _mm_get_last_mode() {
return g_lastmode
}

public _mm_get_next_mode() {
return g_nextmode
}

public boom(id) {
Make_Explode(id, random_num(-4, 4));
}
public plugin_precache() {
	new data[41]
	for(new i = 0; i < 8; i++) {
		formatex(data, charsmax(data), "sprites/minigames/ex_efx%i.spr", i+1);
		g_SprExplode[i] = precache_model(data);
	}
	
	for(new i = 0; i < 10; i++) {
		formatex(data, charsmax(data), "sprites/minigames/x%i.spr", i+1);
		g_SprCountdown[i] = precache_model(data);
	}
	
	g_SprSmoke = precache_model("sprites/minigames/steam1.spr")
	g_SprShockware = precache_model("sprites/minigames/shockwave.spr");
	g_MdlChromeGibs = precache_model("models/minigames/chromegibs.mdl");
	
	formatex(data, charsmax(data), "models/player/%s/%s.mdl", g_MdlChicken, g_MdlChicken);
	precache_model(data);
	formatex(data, charsmax(data), "models/player/%s/%s.mdl", g_MdlTroller, g_MdlTroller);
	precache_model(data);
	
	precache_sound(beep_sound);


}

public FMCmdStart(id, uc_handle, randseed) {
	static button
	if(g_currentmode == ONEBUTTON_MODE) {
	if (is_user_alive(id)) {	
		new Float:MaxSpeed = get_user_maxspeed(id);
		if (MaxSpeed != 1.0) {
			button = get_user_button(id)
			switch(g_AllowButton) {
				case IN_FORWARD: {
					if(button & IN_BACK || button & IN_MOVELEFT || button & IN_MOVERIGHT)
						set_pev(id, pev_maxspeed, 1.0);
						else set_pev(id, pev_maxspeed, 250.0);
					}
					case IN_BACK: {
						if(button & IN_FORWARD || button & IN_MOVELEFT || button & IN_MOVERIGHT)
							set_pev(id, pev_maxspeed, 1.0);
							else set_pev(id, pev_maxspeed, 250.0);
						}
						case IN_MOVELEFT: {
							if(button & IN_FORWARD || button & IN_BACK || button & IN_MOVERIGHT)
							set_pev(id, pev_maxspeed, 1.0);
							else set_pev(id, pev_maxspeed, 250.0);
						}
						case IN_MOVERIGHT: {
							if(button & IN_FORWARD || button & IN_BACK || button & IN_MOVELEFT)
								set_pev(id, pev_maxspeed, 1.0);
							else set_pev(id, pev_maxspeed, 250.0);
						}
					}
				}
			}
		}
		else if(g_currentmode == AWP_JUMP_MODE && get_user_maxspeed(id) != 1.0) {
			new flags = entity_get_int(id, EV_INT_flags)
			
			if (flags & FL_WATERJUMP)
				return PLUGIN_CONTINUE
			
			if ( entity_get_int(id, EV_INT_waterlevel) >= 2 )
				return PLUGIN_CONTINUE
			
			if ( !(flags & FL_ONGROUND) )
				return PLUGIN_CONTINUE
			
			new Float:velocity[3]
			entity_get_vector(id, EV_VEC_velocity, velocity)
			velocity[2] = 250.0
			entity_set_vector(id, EV_VEC_velocity, velocity)
			
			entity_set_int(id, EV_INT_gaitsequence, 6) // Play the Jump Animation
		}
		else if(g_currentmode == UPSIDE_DOWN_MODE) {
			if(is_user_alive(id)) {
				if( g_vecPunchAngles[id][0] < 180.0 ) {
					g_vecPunchAngles[id][0] += 2.0
					g_vecPunchAngles[id][1] = g_vecPunchAngles[id][1] * 2.0
				}
				else {
					g_vecPunchAngles[id][1] = 0.0
				}
				
				entity_set_vector(id, EV_VEC_punchangle, g_vecPunchAngles[id])
			}
		}
	/*
	else if(g_currentmode == RUN_MODE) {
		if(g_speedCheck == WAIT) return PLUGIN_HANDLED;
		
		if(g_speedCheck == DISABLED)
			set_task(8.0, "SpeedCheckEnableStatus", TASK_SPEEDCHECK, _, _, "a", 1);
		
		if(g_speedCheck == ENABLED) SpeedTask();
		
	}
	*/
	return PLUGIN_CONTINUE
	
	
}
public SpeedCheckEnableStatus(id) {
	client_print(0, print_chat, "enable");
	g_speedCheck = ENABLED;
}

public SpeedCheckDisableStatus(id) {
	client_print(0, print_chat, "disable");
	g_speedCheck = DISABLED;
}

public SpeedCheckWaitStatus(id) {
	client_print(0, print_chat, "wait");
	g_speedCheck = WAIT;
}

public OnSecondaryAttack(ent) {
	if(g_currentmode == SCOUT_NOZOOM_MODE)
		return HAM_SUPERCEDE;
	
	return HAM_IGNORED;
}

public CBasePlayer_ResetMaxSpeed (const id){
	if (is_user_alive(id))
	{	
		new Float:MaxSpeed = get_user_maxspeed(id);
		if (MaxSpeed != 1.0) {
			if(g_currentmode == RAMBO_MODE) 
				set_pev(id, pev_maxspeed, 1000.0)
			
			if(g_currentmode == CHICKEN_MODE)
				set_pev(g_choosePlayer, pev_maxspeed, 1000.0)
			
			else set_pev(id, pev_maxspeed, 250.0)
		}
	}
}

public FwdHamTouch_Grenade( iEntity, iTouched ) {
	if(g_currentmode != DEATHLYNADE_MODE) return HAM_IGNORED
	
	if( !( 1 <= iTouched <= g_iMaxPlayers ) )
		return HAM_IGNORED;
	
	static Float:flGmTime;
	flGmTime = get_gametime();
	
	if( g_flLastTouch[iTouched] < flGmTime ) {
		new iOwner = pev( iEntity, pev_owner );
		
		if( iOwner == iTouched )
			return HAM_IGNORED;
		
		if( is_user_connected( iOwner ) ) {
			if( !get_pcvar_num(mp_friendlyfire) && (get_user_team( iTouched ) == get_user_team(iOwner)) )
				return HAM_IGNORED;
			
			if( pev(iTouched, pev_takedamage) == DAMAGE_NO )
				return HAM_IGNORED;
			
			new Float:flVelocity[ 3 ];
			pev( iEntity, pev_velocity, flVelocity );
			
			new Float:flSpeed = vector_length( flVelocity );
			new Float:flDamage = ( flSpeed * 0.15 ) / 13.0;
			
			if( flSpeed > 100.0 ) { // anti grenade stuck bug damage fix
				
				g_iHookedDeathMsg = register_message( g_iMsg_DeathMsg, "MsgDeathMsg" );
				
				new iType = GetGrenadeType( iEntity );
				if( iType != 0 )
					set_pev( iEntity, pev_classname, g_szGrenadeNames[ iType ] );
				
				ExecuteHamB( Ham_TakeDamage, iTouched, iEntity, iOwner, flDamage, DMG_GENERIC );
				
				if( g_iHookedDeathMsg ) {
					unregister_message( g_iMsg_DeathMsg, g_iHookedDeathMsg );
					
					g_iHookedDeathMsg = 0;
				}
				
				if( iType != 0 )
					set_pev( iEntity, pev_classname, "grenade" );
			}
		}
		
		g_flLastTouch[iTouched] = flGmTime + 0.4;
	}
	
	return HAM_IGNORED;
}

public Event_NewRound() {
	// Remove task
	if(task_exists(TASK_LIGHTNORMAL)) remove_task(TASK_LIGHTNORMAL);
	if(task_exists(TASK_COUNTDOWN)) remove_task(TASK_COUNTDOWN);
	if(task_exists(g_choosePlayer + TASK_BOMBCOUNTDOWN)) remove_task(g_choosePlayer + TASK_BOMBCOUNTDOWN);
	if(task_exists(TASK_GIVESMOKENADE)) remove_task(TASK_GIVESMOKENADE);
	
	// Reset chicken model after playing CHICKEN_MODE
	if(g_lastmode == CHICKEN_MODE) {
		set_pcvar_num(mp_friendlyfire, 1)
		flag_unset(g_isChicken, g_choosePlayer);
		cs_reset_player_model(g_choosePlayer);
	}
	
	if(g_lastmode == NIGHTMARE_MODE) {
		set_lights("m");
		
		if(g_currentmode != NIGHTMARE_MODE) Register_Forwards((g_HookState = false));
	}
	
	
	g_currentmode = g_nextmode;
	
	if(g_currentmode == CHANGEMODEL_MODE) {
		set_pcvar_num(mp_friendlyfire, 1)
		client_cmd(0, "hideradar")
		
	}
	else {
		set_pcvar_num(mp_friendlyfire, 0)
		client_cmd(0, "showradar")
	}
	
	ShowModeDescribe();
	
	set_task(0.1, "Countdown_To_ExcMode", TASK_COUNTDOWN, _, _, "a", 1); 
}


public Event_CurWeapon(id) {
	if(g_currentmode == SCOUT_NOZOOM_MODE || g_currentmode == AWP_JUMP_MODE) {
		new iWeapon = read_data(2)
		if( !( NOCLIP_WPN_BS & (1<<iWeapon) ) ) {
			fm_cs_set_weapon_ammo( get_pdata_cbase(id, m_pActiveItem) , g_MaxClipAmmo[ iWeapon ] )
		}
	}
}

public logevent_round_end() {
	
	//set_task(1.0, "SpeedCheckWaitStatus", TASK_SPEEDCHECK, _, _, "a", 1);
	//if(task_exists(g_choosePlayer + TASK_BOMBCOUNTDOWN)) remove_task(g_choosePlayer + TASK_BOMBCOUNTDOWN);
	g_lastmode = g_currentmode;
	g_nextmode = BOMB_MODE //random_num(NORMAL, MODES_COUNT - 1);
	
	while(g_nextmode == INVISIBLE_MODE || g_nextmode == RUN_MODE || g_nextmode == CHICKEN_MODE || g_nextmode == ZEUS_MODE || g_nextmode == REVERSE_MODE
	|| g_nextmode == UPSIDE_DOWN_MODE) {
		g_nextmode = random_num(NORMAL, MODES_COUNT - 1);
	}
	//g_nextmode = RUN_MODE	//g_lastmode = g_currentmode;
	
	client_print(0, print_chat, "Next mode will be: %i", g_nextmode);
	
	g_iCountdown = floatround(get_pcvar_float(mp_freezetime)) - 1;
	if(task_exists(TASK_COUNTDOWN)) remove_task(TASK_COUNTDOWN);
	
	switch(g_nextmode) {
		case SCOUT_NOZOOM_MODE: {}
		
		case KNIFE_HP_MODE: {
			g_extraVar = random_num(0, 2);
			
			if(g_extraVar == 0) formatex(g_szDescribe[KNIFE_HP_MODE], 4, "1 HP");
			else if(g_extraVar == 1) formatex(g_szDescribe[KNIFE_HP_MODE], 5, "35 HP");
				else formatex(g_szDescribe[KNIFE_HP_MODE], 6, "100 HP");
		}
		case ONEBUTTON_MODE: {
			g_extraVar = random_num(0, 3);
			
			if(g_extraVar == 0) {
				g_AllowButton = IN_FORWARD;
				formatex(g_szDescribe[ONEBUTTON_MODE], 23, "Only use Forward Button");
			}
			else if(g_extraVar == 1) { 
				g_AllowButton = IN_BACK;
				formatex(g_szDescribe[ONEBUTTON_MODE], 20, "Only use Back Button");
			}
			else if(g_extraVar == 2) {
				g_AllowButton = IN_MOVELEFT;
				formatex(g_szDescribe[ONEBUTTON_MODE], 20, "Only use Left Button");
			}
			else if(g_extraVar == 3) {
				g_AllowButton = IN_MOVERIGHT;
				formatex(g_szDescribe[ONEBUTTON_MODE], 21, "Only use Right Button");
			}	
		}
		case UPSIDE_DOWN_MODE: {
			for(new id =1; id <= g_iMaxPlayers; id++) {
				g_vecPunchAngles[id][0] = 0.0
				g_vecPunchAngles[id][1] = 0.0
			}
		}
	}
}
public HamSpawn(id) {
	new iParam[1]
	iParam[0] = g_currentmode;
	
	if(is_user_alive(id)) {
		if(g_lastmode == FLY_MODE && g_lastmode != g_currentmode)
			set_user_noclip(id, 0);
		
		// Reset player speed after playing RAMBO_MODE
		if(g_lastmode == RAMBO_MODE && g_lastmode != g_currentmode)
			set_user_maxspeed(id, 250.0);
		
		if(g_lastmode == CHANGEMODEL_MODE) {
			cs_reset_player_model(id);
			
			if(g_currentmode != CHANGEMODEL_MODE) Register_Forwards((g_HookState = false));
		}
		
		if(g_currentmode != FLY_MODE && g_currentmode != ONEBUTTON_MODE && g_currentmode != NIGHTMARE_MODE && g_currentmode != NORMAL && g_currentmode != TPV_MODE && g_currentmode != CHICKEN_MODE && g_currentmode != AWP_JUMP_MODE && g_currentmode != REVERSE_MODE && g_currentmode != UPSIDE_DOWN_MODE && g_currentmode != CHANGEMODEL_MODE) {
			//client_print(0, print_chat, "Can't use weapon");
			strip_user_weapons(id);
		}
		else {
			//client_print(0, print_chat, "Can use weapon");
			give_item(id, "weapon_knife");
		}
	}
	set_task(get_pcvar_float(mp_freezetime), "Start_Chosen_Mode", TASK_START, iParam, 1, "a", 1);		
}


public Start_Chosen_Mode(iParam[], id) {
	new mode = iParam[0];
	
	
	switch(mode) {
		case NORMAL:{
			return;
		}
		
		case SCOUT_NOZOOM_MODE: {
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id)) {
					strip_user_weapons(id);
					fm_give_item(id, "weapon_scout");
				}
			}
		}
		case KNIFE_HP_MODE: {
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id)) {
					strip_user_weapons(id);
					fm_give_item(id, "weapon_knife");
					if(g_extraVar == 0) set_user_health(id, 1);
					else if(g_extraVar == 1) set_user_health(id, 35);
						else set_user_health(id, 100);
				}
			}
		}
		
		case TPV_MODE: {
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id)) {
					Create_PlayerCamera(id);
				}
			}
		}
		
		case CHANGEMODEL_MODE: {
			Register_Forwards((g_HookState = true));
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id) ) {
					cs_set_player_model(id, "nguoique");
				}
			}
		}
		
		case BOMB_MODE: Exc_Bomb_Mode();
			
		case CHICKEN_MODE: Set_Random_Player_To_Chicken();
			
		case ZEUS_MODE:{}
		
		case RAMBO_MODE:{
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id)) {
					strip_user_weapons(id);
					give_item(id, "weapon_m249");
					give_item(id, "weapon_knife");
					set_user_health(id, 1000);
					//set_user_maxspeed(id, 800.0);
				}
			}
		}
		case AWP_JUMP_MODE: {
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id)) {
					strip_user_weapons(id);
					fm_give_item(id, "weapon_awp");
				}
			}
		}
		case ONEBUTTON_MODE: {}
		
		case NIGHTMARE_MODE: {
			Register_Forwards((g_HookState = true));
			set_lights("a");
			set_task(get_pcvar_float(cvar_lightfreq), "ShowLight", TASK_LIGHTNORMAL, _, _, "b");
			client_cmd(0, "hideradar")
		}
		case FLY_MODE: {
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id) )
					set_user_noclip(id, 1);
			}
		}
		case DEATHLYNADE_MODE: {
			for(new id = 1; id <= g_iMaxPlayers; id++) {
				if(is_user_alive(id)) {
					strip_user_weapons(id);
					set_user_health(id, 1);
					give_item(id, "weapon_smokegrenade");
				}
			}
		}
	}
}

public ShowLight(id) {
	set_lights("m");
	set_task(1.0, "DarkAgain", TASK_LIGHTDARK, _, _, "a", 1);
}

public DarkAgain(id) {
	set_lights("a");
	
	if(task_exists(TASK_LIGHTDARK)) remove_task(TASK_LIGHTDARK);
}

public OnEmitSound(entity, channel, const sound[])
{
	if(equal(sound, "weapons/sg_explode.wav"))
	{
		new id = pev(entity, pev_owner)
		EF_RemoveEntity(entity)
		give_item(id, "weapon_smokegrenade");
		set_pev(id, pev_viewmodel, 1);
		return FMRES_SUPERCEDE
	}
	return FMRES_IGNORED
}

public cmdCam(id) {
	Create_PlayerCamera(id)
}

public EventDeathMsg(id) {
	g_remove[id] = true;
	
	if(g_currentmode == CHANGEMODEL_MODE) {
		new iAttacker = read_data(1);
		new iVictim = read_data(2);
		
		if(cs_get_user_team(iAttacker) == cs_get_user_team(iVictim)) {
			client_print(0, print_chat, "Kill team");
			user_kill(iAttacker);
		}
	}
}

public MsgDeathMsg( ) {
	if(g_currentmode == DEATHLYNADE_MODE) {
		set_msg_arg_int( 3, ARG_BYTE, 1 );
		set_msg_arg_string( 4, "grenade" );
	}
	
	return PLUGIN_CONTINUE;
}

public client_disconnect(id)
{
	g_remove[id] = true;
}

Create_PlayerCamera(id)
{
	new ent = -1
	while ((ent = find_ent_by_class(ent,pl_cm_class)) != 0)
	{
		if (entity_get_edict(ent,EV_ENT_owner) == id)
		{
			attach_view(id , ent)
			return
		}
	}
	ent = create_entity("info_target")

	if( !ent )
		return;
		
	entity_set_string(ent, EV_SZ_classname, pl_cm_class)
		
	entity_set_model(ent, "models/w_usp.mdl")
		
	entity_set_byte(ent, EV_INT_solid, SOLID_TRIGGER)
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_FLYMISSILE)
		
	entity_set_edict(ent, EV_ENT_owner, id)
		
	entity_set_int(ent,EV_INT_rendermode, kRenderTransTexture)
	entity_set_float(ent, EV_FL_renderamt, 0.0 )
		
	attach_view(id,ent)
	entity_set_float(ent, EV_FL_nextthink, get_gametime())
}

public Think_PlayerCamera(ent)
{
	static owner
	owner = entity_get_edict(ent,EV_ENT_owner)
	
	if( g_remove[owner] ) {
		g_remove[owner] = 0
		attach_view(owner,owner)
		remove_entity(ent)
		return PLUGIN_CONTINUE;
	}
	
	static Float:origin[3], Float:fAngle[3],Float:origin2[3];
	entity_get_vector(owner,EV_VEC_origin,origin)
	entity_get_vector(owner,EV_VEC_v_angle,fAngle)
	
	origin2[0] = origin[0]
	origin2[1] = origin[1]
	origin2[2] = origin[2]
	
	static Float:fVBack[3];
	angle_vector( fAngle, ANGLEVECTOR_FORWARD, fVBack );
	
	origin[2] += 20.0;
	
	origin[0] += ( -fVBack[0] * 150.0 );
	origin[1] += ( -fVBack[1] * 150.0 );
	origin[2] += ( -fVBack[2] * 150.0 );
	
	trace_line(owner,origin2,origin,origin)
	
	entity_set_vector(ent,EV_VEC_origin,origin)
	
	entity_get_vector(owner,EV_VEC_velocity,origin2)
	entity_set_vector(ent,EV_VEC_velocity,origin2)
	
	entity_set_vector(ent,EV_VEC_angles,fAngle)
	entity_set_float(ent, EV_FL_nextthink, get_gametime())
	
	return PLUGIN_CONTINUE;
}  


public Countdown_To_ExcMode() {
	if(g_iCountdown == 0) 
		return;
	
	client_print(0, print_center, "Game will begin in %i second(s)", g_iCountdown);
	g_iCountdown--;
	set_task(1.0, "Countdown_To_ExcMode", TASK_COUNTDOWN);
}

public Exc_Bomb_Mode() {
	new playersEnt[32]
	new iPlayerCount
	get_players(playersEnt, iPlayerCount, "a")
	
	if(iPlayerCount <= 1) return;
	
	g_choosePlayer = playersEnt[random(iPlayerCount)];
	new name[32]
	get_user_name(g_choosePlayer, name, charsmax(name));
	set_dhudmessage(0, 225, 0, -1.0, 0.25, 1, 0.1, 1.0, 0.1, 0.1 );
	show_dhudmessage(0, " %s is the next SUICIDE bomber", name);
	flag_set(g_isHoldingBomb, g_choosePlayer);
	g_iBombCountdown = 10;
	set_task(1.0, "bomb_countdown", g_choosePlayer+TASK_BOMBCOUNTDOWN, _, _, "b");
}

public bomb_countdown(id) {
	static name[32]
	get_user_name(g_choosePlayer, name, charsmax(name));
	
	id -= TASK_BOMBCOUNTDOWN;
	if(g_iBombCountdown > 0) {
		set_hudmessage( 225, 0, 0, -1.0, 0.29, 1, 0.1, 1.0, 0.1, 0.1 );
		show_hudmessage(0, "%s will be explode after %i second(s)", name, g_iBombCountdown);
		emit_sound(g_choosePlayer,CHAN_BODY,"weapons/mm_bomb_beep.wav",1.0,ATTN_NORM,0,PITCH_NORM)
		
		Make_Spr_Countdown(id, g_iBombCountdown - 1);
		
		g_iBombCountdown--;
		if(!is_user_alive(id)) {
			remove_task(id+TASK_BOMBCOUNTDOWN);
			client_print(0, print_chat, "Bomber is dead suddenly. Server will choose another player to be a bomber");
			
			set_task(1.0, "Exc_Bomb_Mode", TASK_CHOOSEBOMBERAGAIN, _, _, "a", 1);
		}
	}
	else {
		//client_print(0, print_chat, "BOOOM");
		user_kill(id);
		Make_Explode(id, random_num(-4, 4));
		
		flag_unset(g_isHoldingBomb, id);
		
		new Float:originF[3]
		pev(id, pev_origin, originF);
		static a
		new Float:radius = get_pcvar_float(cvar_damageradius);
		
		while((a = find_ent_in_sphere(a,originF,radius)) != 0) {
			if(a != id && is_user_alive(a)) {
				user_silentkill(a);
				Create_DeathMsg(a, id)
			}
		}
		remove_task(id+TASK_BOMBCOUNTDOWN);
		
		Exc_Bomb_Mode();
	}	
}

public TraceAttack(victim, attacker, Float:damage, Float:direction[3], tracehandle, damagebits)
{
	if(g_currentmode == BOMB_MODE) return HAM_SUPERCEDE
	if(g_currentmode != CHANGEMODEL_MODE) {
		return HAM_IGNORED
	}
	
	//client_print(0, print_chat, "TraceAttack");
	if( victim != attacker && (1 <= attacker <= g_iMaxPlayers) )
	{
		new vteam = fm_get_user_team(victim)
		/*
		// If playing chicken mode
		if(g_currentmode == CHICKEN_MODE) {
			//new ateam = fm_get_user_team(attacker);
			
			// Only allow take damage chicken and ignore human 
			if (flag_get_boolean(g_isChicken, victim) || flag_get_boolean(g_isChicken, attacker)) {
				fm_set_user_team(victim, vteam == 1 ? 2 : 1)
				ExecuteHamB(Ham_TraceAttack, victim, attacker, damage, direction, tracehandle, damagebits)
				fm_set_user_team(victim, vteam)
				return HAM_SUPERCEDE
			}
		}
		*/
		if(g_currentmode == CHANGEMODEL_MODE) {
			if( vteam == fm_get_user_team(attacker) ) {
				fm_set_user_team(victim, vteam == 1 ? 2 : 1)
				ExecuteHamB(Ham_TraceAttack, victim, attacker, damage, direction, tracehandle, damagebits)
				fm_set_user_team(victim, vteam)
				return HAM_SUPERCEDE
			}
		}
	}
	return HAM_IGNORED
}

public TakeDamage(victim, idinflictor, attacker, Float:damage, damagebits)
{
	if(g_currentmode == BOMB_MODE) return HAM_SUPERCEDE
	if(g_currentmode != CHANGEMODEL_MODE) return HAM_IGNORED
	
	//client_print(0, print_chat, "TakeDamage");
	if( victim != attacker && (1 <= attacker <= g_iMaxPlayers) )
	{
		new vteam = fm_get_user_team(victim)
		/*
		// If playing chicken mode
		if(g_currentmode == CHICKEN_MODE) {
			//new ateam = fm_get_user_team(attacker);
			
			// Only allow take damage chicken and ignore human 
			if (flag_get_boolean(g_isChicken, victim) || flag_get_boolean(g_isChicken, attacker)) {
				fm_set_user_team(victim, vteam == 1 ? 2 : 1)
				ExecuteHamB(Ham_TakeDamage, victim, idinflictor, attacker, damage, damagebits)
				fm_set_user_team(victim, vteam)
				return HAM_SUPERCEDE
			}
			else return HAM_SUPERCEDE
		}
		*/
		if(g_currentmode == CHANGEMODEL_MODE) {
			if( vteam == fm_get_user_team(attacker) ) {
				fm_set_user_team(victim, vteam == 1 ? 2 : 1)
				ExecuteHamB(Ham_TakeDamage, victim, idinflictor, attacker, damage, damagebits)
				fm_set_user_team(victim, vteam)
				return HAM_SUPERCEDE
			}
		}
	}
	return HAM_IGNORED
	
}

public Killed(victim, attacker, shouldgib)
{
	if(g_currentmode != CHANGEMODEL_MODE) return HAM_IGNORED
	
	//client_print(0, print_chat, "HamKilled");
	if( victim != attacker && (1 <= attacker <= g_iMaxPlayers) )
	{
		new vteam = fm_get_user_team(victim)
		/*
		// If playing chicken mode
		if(g_currentmode == CHICKEN_MODE) {
			//new ateam = fm_get_user_team(attacker);
			
			// Only allow take damage chicken and ignore human 
			if (flag_get_boolean(g_isChicken, victim) || flag_get_boolean(g_isChicken, attacker)) {
				fm_set_user_team(victim, vteam == 1 ? 2 : 1)
				ExecuteHamB(Ham_Killed, victim, attacker, shouldgib)
				fm_set_user_team(victim, vteam)
				return HAM_SUPERCEDE
			}
			else return HAM_SUPERCEDE
		}
		*/
		if(g_currentmode == CHANGEMODEL_MODE) {
			if( vteam == fm_get_user_team(attacker) ) {
				fm_set_user_team(victim, vteam == 1 ? 2 : 1)
				ExecuteHamB(Ham_Killed, victim, attacker, shouldgib)
				fm_set_user_team(victim, vteam)
				return HAM_SUPERCEDE
			}
		}
	}
	return HAM_IGNORED
	
}


public Message_Radar(iMsgId, MSG_DEST, id)
{
	return PLUGIN_HANDLED
}

Set_Random_Player_To_Chicken() {
	new playersEnt[32]
	new iPlayerCount
	get_players(playersEnt, iPlayerCount, "a")
	
	if(iPlayerCount == 1) return;
	
	g_choosePlayer = playersEnt[random(iPlayerCount)];
	flag_set(g_isChicken, g_choosePlayer);
	new name[32]
	get_user_name(g_choosePlayer, name, charsmax(name));
	client_print(0, print_chat, "%s", name);
	
	cs_set_player_model(g_choosePlayer, g_MdlChicken);
	strip_user_weapons(g_choosePlayer)
	give_item(g_choosePlayer, "weapon_knife");
	set_user_hitzones(0, g_choosePlayer, 193);
	
	Create_PlayerCamera(g_choosePlayer);
	
}

public CreateNamedEntity(iClassName)
{
	static iKnifeClass
	
	if( (iKnifeClass || (iKnifeClass=is_class_knife(iClassName))) && iClassName == iKnifeClass)
	{
		if(g_currentmode == SCOUT_NOZOOM_MODE)
		{
			return FMRES_SUPERCEDE
		}
	}
	return FMRES_IGNORED
}

is_class_knife(iClassName)
{
new szClassName[13]
global_get(glb_pStringBase, iClassName, szClassName, 12)
if( equal(szClassName, "weapon_knife") )
{
	return iClassName
}
return 0
}

stock bool:fm_strip_user_gun(index, wid = 0, const wname[] = "")
{
new ent_class[32]
if (!wid && wname[0])copy(ent_class, sizeof ent_class - 1, wname)
else
{
	new weapon = wid, clip, ammo
	if (!weapon && !(weapon = get_user_weapon(index, clip, ammo)))return false
	
	get_weaponname(weapon, ent_class, sizeof ent_class - 1)
}

new ent_weap = fm_find_ent_by_owner(-1, ent_class, index)
if (!ent_weap)return false

engclient_cmd(index, "drop", ent_class)

new ent_box = pev(ent_weap, pev_owner)
if (!ent_box || ent_box == index)return false

dllfunc(DLLFunc_Think, ent_box)

return true
}

stock fm_give_item(index, const item[])
{
if (!equal(item, "weapon_", 7) && !equal(item, "ammo_", 5) && !equal(item, "item_", 5) && !equal(item, "tf_weapon_", 10))return 0

new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, item))
if (!pev_valid(ent))return 0

new Float:origin[3]
pev(index, pev_origin, origin)
set_pev(ent, pev_origin, origin)
set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags) | SF_NORESPAWN)
dllfunc(DLLFunc_Spawn, ent)

new save = pev(ent, pev_solid)
dllfunc(DLLFunc_Touch, ent, index)
if (pev(ent, pev_solid) != save)return ent

engfunc(EngFunc_RemoveEntity, ent)

return -1
}

stock fm_find_ent_by_owner(index, const classname[], owner, jghgtype = 0)
{
new strtype[11] = "classname", ent = index
switch (jghgtype)
{
	case 1: strtype = "target"
		case 2: strtype = "targetname"
		}
	
	while ((ent = engfunc(EngFunc_FindEntityByString, ent, strtype, classname)) && pev(ent, pev_owner) != owner) {}
	return ent
}

stock Float:fm_get_ent_speed(id)
{
	if(!pev_valid(id))
		return 0.0;
	
	static Float:vVelocity[3];
	pev(id, pev_velocity, vVelocity);
	
	vVelocity[2] = 0.0;
	
	return vector_length(vVelocity);
}  
SpeedTask() {
	static id, Float:minspeed
	minspeed = fm_get_ent_speed(id);
	for(id = 1; id <= g_iMaxPlayers; id++) {
		if(is_user_alive(id)) {
			minspeed = fm_get_ent_speed(id);
			
			if(minspeed < get_pcvar_float(cvar_runminspeed)) {
				user_kill(id);
				Make_Explode(id, random_num(-4, 4));
			}
			else continue;
		}
		else continue;
	}
}
public Create_DeathMsg( Victim, Attacker )
{
	message_begin(MSG_BROADCAST, get_user_msgid("DeathMsg"), {0,0,0});
	write_byte(Attacker);
	write_byte(Victim);
	write_byte(1)
	write_string("worldspawn");
	message_end();
}

Make_Explode(id, spriteNum) {
	new Explosion_Origin[3]
	
	emit_sound(id,CHAN_BODY,"weapons/c4_explode1.wav",1.0,ATTN_NORM,0,PITCH_NORM)
	
	get_user_origin(id,Explosion_Origin,0)
	
	Explode1(Explosion_Origin)
	
	g_SprRandom = spriteNum
	
	if(g_SprRandom == -4)
		Explode2(Explosion_Origin)
	
	if(g_SprRandom == -3)
		Explode3(Explosion_Origin)
	
	if(g_SprRandom == -2)
		Explode4(Explosion_Origin)
	
	if(g_SprRandom == -1)
		Explode5(Explosion_Origin)
	
	if(g_SprRandom == 0)
		Explode6(Explosion_Origin)
	
	if(g_SprRandom == 1)
		Explode7(Explosion_Origin)
	
	if(g_SprRandom == 2)
		Explode8(Explosion_Origin)
	
	if(g_SprRandom == 3)
		Explode9(Explosion_Origin)
	
	if(g_SprRandom == 4)
		Explode10(Explosion_Origin)
}

Explode1(vec1[3]) //Explosion Effects Below
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(19)                                      //Ring that expands to max radius over lifetime
write_coord(vec1[0])                                //Center Position 
write_coord(vec1[1])                                //Center Position
write_coord(vec1[2]+40)                             //Center Position
write_coord(vec1[0]+1500)                           //Axis and Radius
write_coord(vec1[1]+1500)                           //Axis and Radius
write_coord(vec1[2]+1500)                           //Axis and Radius
write_short(g_SprShockware)                       //Sprite Index
write_byte(0)                                       //Starting Frame
write_byte(00)                                      //Frame Rate in 0.1
write_byte(15)                                      //Life in 0.1
write_byte(70)                                      //Line Width in 0.1
write_byte(000)                                     //Noise Amplitude in 0.01
write_byte(255)                                     //Red 
write_byte(255)                                     //Green 
write_byte(255)                                     //Blue 
write_byte(04)                                      //Brightness
write_byte(0)                                       //Scroll Speed in 0.1
message_end()

message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(4)                                       //TarBaby Explosion With Sound Effect
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 45)                           //Center Position Z
message_end()

message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(4)                                       //TarBaby Explosion With Sound Effect
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 30)                           //Center Position Z
message_end()

message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(4)                                       //TarBaby Explosion With Sound Effect
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 15)                           //Center Position Z 
message_end() 

message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(5)                                       //Makes One Sprite Which Moves Upwards 30 Pixels
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprSmoke)                           //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(20)                                      //Framerate
message_end()

message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(107)                                     //Spherical Shower of Models, Picks From Set
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 30)                           //Center Position Z 
write_coord(888)                                    //Velocity
write_short(g_MdlChromeGibs)                       //Model Index
write_short(10)                                     //Count
write_byte(25)                                      //Life in 0.1's
message_end()
}

Explode2(vec1[3]) 
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprExplode[0])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode3(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprExplode[1])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode4(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 130)                          //Center Position Z
write_short(g_SprExplode[2])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode5(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 115)                          //Center Position Z
write_short(g_SprExplode[3])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode6(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprExplode[4])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode7(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 130)                          //Center Position Z
write_short(g_SprExplode[5])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode8(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprExplode[6])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode9(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1)
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprExplode[7])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Explode10(vec1[3])
{
message_begin(MSG_BROADCAST,SVC_TEMPENTITY,vec1) 
write_byte(3)                                       //Makes One Sprite Which Moves Upwards, Two Dynamic Lights and Flickering Particles
write_coord(vec1[0] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[1] + (g_SprRandom * 5))      //Center Position X
write_coord(vec1[2] + 55)                           //Center Position Z
write_short(g_SprExplode[8])                      //Sprite Index
write_byte(040)                                     //Scale in 0.1
write_byte(18)                                      //Framerate
write_byte(4)                                       //Flags, 4 Disables Additive Sound
message_end()
}

Make_Spr_Countdown(id, sprNum) {
new spr = g_SprCountdown[sprNum];

message_begin(MSG_ALL, SVC_TEMPENTITY);
write_byte(TE_PLAYERATTACHMENT);
write_byte(id);
write_coord(60);
write_short(spr);
write_short(10);
message_end();

set_task(1.1, "Remove_Spr_Countdown", 31231, _,_, "a", 1);
}

public Remove_Spr_Countdown(id) {
message_begin( MSG_ALL, SVC_TEMPENTITY );
write_byte(TE_KILLPLAYERATTACHMENTS );
write_byte(id);
message_end();
}

Register_Forwards(bool:bState)
{
if(bState)
{
//client_print(0, print_chat, "registed");
EnableHamForward( g_hTraceAttack )
EnableHamForward( g_hTakeDamage )
EnableHamForward( g_hKilled )
if( !g_mRadarHook )
register_message( gmsgRadar, "Message_Radar")
}
else
{
//client_print(0, print_chat, "unregisted");
DisableHamForward( g_hTraceAttack )
DisableHamForward( g_hTakeDamage )
DisableHamForward( g_hKilled )
if( g_mRadarHook )
{
unregister_message(gmsgRadar, g_mRadarHook)
g_mRadarHook = 0
}
}
}

GetGrenadeType( iEntity ) {
if( !pev_valid( iEntity ) )
return 0;

new szModel[ 32 ];
pev( iEntity, pev_model, szModel, charsmax( szModel ) );

if( szModel[ 7 ] != 'w' && szModel[ 8 ] != '_' )
return 0;

switch( szModel[ 9 ] ) {
case 'h': return 1;
case 'f': return 2;
case 's': return 3;
default : return 0;
}

return 0;
}
ShowModeDescribe() {
set_task(0.5, "ShowModeName", TASK_MODENAME, _, _, "a", 1);
set_task(1.5, "ShowModeDes", TASK_MODEDES, _, _, "a", 1);
}

public ShowModeName(id) {
ColorChat(0, GREEN, "[NTC] ^x03The mode will be played this round: ^x04%s", g_szMode[g_currentmode]);
}

public ShowModeDes(id) {
ColorChat(0, GREEN, "[NTC] ^x03Weapon: ^x04%s ^x03| ^x04%s", g_szWeapon[g_currentmode], g_szDescribe[g_currentmode]);
}

/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
